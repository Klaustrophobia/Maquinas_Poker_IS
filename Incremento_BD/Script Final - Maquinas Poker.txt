-- ENUMS

DROP TYPE IF EXISTS estado_maquina CASCADE;
CREATE TYPE estado_maquina AS ENUM ('Fuera de servicio', 'Mantenimiento', 'Funcionando');

DROP TYPE IF EXISTS estado_orden CASCADE;
CREATE TYPE estado_orden AS ENUM ('Asignada', 'Proceso', 'Completada');

DROP TYPE IF EXISTS estado_solicitud CASCADE;
CREATE TYPE estado_solicitud AS ENUM ('pendiente', 'tecnico_asignado', 'prefinalizada', 'finalizada');

DROP TYPE IF EXISTS gravedad_falla CASCADE;
CREATE TYPE gravedad_falla AS ENUM ('leve', 'moderada', 'grave');

DROP TYPE IF EXISTS tipo_rol CASCADE;
CREATE TYPE tipo_rol AS ENUM ('SuperAdmin', 'Administrador', 'Tecnico', 'Cliente');

-- TABLAS INICIALES

CREATE TABLE usuarios (
  id bigint primary key generated always as identity,
  nombre_usuario text not null unique,
  contraseña text not null,
  rol tipo_rol not null,
  correo text not null unique,
  fecha_creacion timestamptz default now(),
  identificador_unico text UNIQUE,
  activo boolean DEFAULT true,
  codigo_login text
);

CREATE TABLE maquinas (
  id bigint primary key generated always as identity,
  nombre text not null,
  tipo text not null,
  estado estado_maquina not null,
  ubicacion text not null,
  fecha_compra date,
  fecha_garantia date
);

CREATE TABLE ordenes_reparacion (
  id bigint primary key generated always as identity,
  maquina_id bigint references maquinas (id),
  cliente_id bigint references usuarios (id),
  tecnico_id bigint references usuarios (id),
  fecha_orden timestamptz default now(),
  estado estado_orden not null,
  descripcion text,
  fecha_finalizacion timestamptz
);

CREATE TABLE contabilidad (
  id bigint primary key generated always as identity,
  fecha_transaccion timestamptz default now(),
  monto numeric not null,
  tipo text not null,
  descripcion text,
  orden_reparacion_id bigint references ordenes_reparacion (id)
);

CREATE TABLE proveedores (
  id bigint primary key generated always as identity,
  nombre text not null,
  informacion_contacto text,
  direccion text,
  fecha_creacion timestamptz default now()
);

CREATE TABLE repuestos (
  id bigint primary key generated always as identity,
  nombre text not null,
  proveedor_id bigint references proveedores (id),
  cantidad int not null,
  ubicacion text,
  estado text not null
);

CREATE TABLE recibos (
  id bigint primary key generated always as identity,
  cliente_id bigint references usuarios (id),
  maquina_id bigint references maquinas (id),
  monto numeric not null,
  fecha_recibo timestamptz default now()
);

CREATE TABLE vales_pago (
  id bigint primary key generated always as identity,
  tecnico_id bigint references usuarios (id),
  monto numeric not null,
  fecha_vale timestamptz default now()
);

CREATE TABLE orden_reparacion_repuestos (
  id bigint primary key generated always as identity,
  orden_reparacion_id bigint references ordenes_reparacion (id),
  repuesto_id bigint references repuestos (id),
  cantidad int not null
);

CREATE TABLE maquinas_cliente (
  id bigint primary key generated always as identity,
  cliente_id bigint references usuarios (id),
  maquina_id bigint references maquinas (id),
  estado text not null,
  fecha_asignacion timestamptz default now()
);

CREATE TABLE roles (
  id bigint primary key generated always as identity,
  nombre tipo_rol not null unique,
  descripcion text,
  permisos jsonb,
  fecha_creacion timestamp with time zone default now()
);

-- TABLAS AGREGADAS

CREATE TABLE IF NOT EXISTS solicitudes_reparacion
(
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    cliente_id bigint NOT NULL REFERENCES usuarios(id),
    maquina_id bigint NOT NULL REFERENCES maquinas(id),
    descripcion_falla text NOT NULL,
    gravedad gravedad_falla NOT NULL,
    estado estado_solicitud DEFAULT 'pendiente',
    tecnico_asignado_id bigint REFERENCES usuarios(id),
    fecha_hora_reparacion timestamptz,
    fecha_creacion timestamptz DEFAULT now(),
    fecha_actualizacion timestamptz DEFAULT now(),
    observaciones_tecnico text,
    fecha_reparacion_terminada timestamptz,
    fecha_finalizada timestamptz
);

CREATE TABLE IF NOT EXISTS repuestos_utilizados
(
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    solicitud_id bigint NOT NULL REFERENCES solicitudes_reparacion(id),
    repuesto_id bigint NOT NULL REFERENCES repuestos(id),
    cantidad_utilizada integer NOT NULL,
    fecha_uso timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS notificaciones
(
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    usuario_id bigint NOT NULL REFERENCES usuarios(id),
    titulo text NOT NULL,
    mensaje text NOT NULL,
    tipo text NOT NULL,
    leida boolean DEFAULT false,
    fecha_creacion timestamptz DEFAULT now(),
    relacion_id bigint
);

-- INDEXES

CREATE INDEX IF NOT EXISTS idx_solicitudes_cliente ON solicitudes_reparacion(cliente_id);
CREATE INDEX IF NOT EXISTS idx_solicitudes_maquina ON solicitudes_reparacion(maquina_id);
CREATE INDEX IF NOT EXISTS idx_solicitudes_tecnico ON solicitudes_reparacion(tecnico_asignado_id);
CREATE INDEX IF NOT EXISTS idx_solicitudes_estado ON solicitudes_reparacion(estado);
CREATE INDEX IF NOT EXISTS idx_solicitudes_fecha_creacion ON solicitudes_reparacion(fecha_creacion DESC);

CREATE INDEX IF NOT EXISTS idx_repuestos_utilizados_solicitud ON repuestos_utilizados(solicitud_id);
CREATE INDEX IF NOT EXISTS idx_repuestos_utilizados_repuesto ON repuestos_utilizados(repuesto_id);

CREATE INDEX IF NOT EXISTS idx_notificaciones_usuario ON notificaciones(usuario_id);
CREATE INDEX IF NOT EXISTS idx_notificaciones_leida ON notificaciones(leida);


-- TRIGGER ACTUALIZACION DE FECHA

CREATE OR REPLACE FUNCTION actualizar_fecha_actualizacion()
RETURNS TRIGGER AS $$
BEGIN
    NEW.fecha_actualizacion = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_actualizar_fecha_solicitudes
BEFORE UPDATE ON solicitudes_reparacion
FOR EACH ROW EXECUTE FUNCTION actualizar_fecha_actualizacion();

-- TRIGGER CAMBIAR ESTADO DE UNA MAQUINA

CREATE OR REPLACE FUNCTION cambiar_estado_maquina_solicitud()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' AND NEW.estado = 'pendiente' THEN
        UPDATE maquinas SET estado = 'Fuera de servicio' WHERE id = NEW.maquina_id;
        UPDATE maquinas_cliente
        SET estado = 'Fuera de servicio'
        WHERE maquina_id = NEW.maquina_id AND cliente_id = NEW.cliente_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cambiar_estado_maquina_insert
AFTER INSERT ON solicitudes_reparacion
FOR EACH ROW EXECUTE FUNCTION cambiar_estado_maquina_solicitud();


-- TRIGGER CAMBIAR ESTADO DE UNA MAQUINA

CREATE OR REPLACE FUNCTION cambiar_estado_maquina_actualizacion()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.estado = 'finalizada' AND OLD.estado != 'finalizada' THEN
        UPDATE maquinas SET estado = 'Funcionando' WHERE id = NEW.maquina_id;
        UPDATE maquinas_cliente
        SET estado = 'Funcionando'
        WHERE maquina_id = NEW.maquina_id AND cliente_id = NEW.cliente_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cambiar_estado_maquina_update
AFTER UPDATE ON solicitudes_reparacion
FOR EACH ROW EXECUTE FUNCTION cambiar_estado_maquina_actualizacion();

-- TRIGGER NOTIFICACIONES AUTOMATICAS

DROP TRIGGER IF EXISTS trigger_notificaciones_solicitudes ON solicitudes_reparacion;

CREATE OR REPLACE FUNCTION crear_notificacion_automatica()
RETURNS TRIGGER AS $$
DECLARE
    admin_id bigint;
    maquina_nombre text;
    cliente_nombre text;
    tecnico_nombre text;
BEGIN
    SELECT nombre INTO maquina_nombre FROM maquinas WHERE id = NEW.maquina_id;
    SELECT nombre_usuario INTO cliente_nombre FROM usuarios WHERE id = NEW.cliente_id;

    /* 1. Creación de solicitud */
    IF TG_OP = 'INSERT' THEN
        INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
        VALUES (NEW.cliente_id,
                'Solicitud creada',
                'Se creó la solicitud para la máquina ' || maquina_nombre,
                'solicitud_creada',
                NEW.id);

        FOR admin_id IN SELECT id FROM usuarios
                        WHERE rol IN ('SuperAdmin', 'Administrador')
                        AND activo = true
        LOOP
            INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
            VALUES (admin_id,
                    'Nueva solicitud registrada',
                    'El cliente ' || cliente_nombre || ' reportó una falla en ' || maquina_nombre,
                    'nueva_solicitud',
                    NEW.id);
        END LOOP;
    END IF;

    /* 2. Técnico asignado */
    IF TG_OP = 'UPDATE'
       AND NEW.tecnico_asignado_id IS NOT NULL 
       AND (OLD.tecnico_asignado_id IS NULL OR OLD.tecnico_asignado_id != NEW.tecnico_asignado_id) THEN

        SELECT nombre_usuario INTO tecnico_nombre FROM usuarios WHERE id = NEW.tecnico_asignado_id;

        INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
        VALUES (NEW.cliente_id,
                'Técnico asignado',
                'El técnico ' || tecnico_nombre || ' ha sido asignado.',
                'tecnico_asignado',
                NEW.id);

        INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
        VALUES (NEW.tecnico_asignado_id,
                'Nueva orden de trabajo',
                'Debe reparar la máquina ' || maquina_nombre || ' del cliente ' || cliente_nombre,
                'orden_trabajo',
                NEW.id);
    END IF;

    /* 3. Prefinalizada */
    IF TG_OP = 'UPDATE' AND NEW.estado = 'prefinalizada' AND OLD.estado != 'prefinalizada' THEN
        INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
        VALUES (NEW.cliente_id,
                'Reparación completada',
                'El técnico completó la reparación de la máquina ' || maquina_nombre,
                'reparacion_completada',
                NEW.id);
    END IF;

    /* 4. Finalizada */
    IF TG_OP = 'UPDATE' AND NEW.estado = 'finalizada' AND OLD.estado != 'finalizada' THEN
        FOR admin_id IN SELECT id FROM usuarios
                        WHERE rol IN ('SuperAdmin', 'Administrador')
                        AND activo = true
        LOOP
            INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
            VALUES (admin_id,
                    'Reparación finalizada',
                    'La reparación de ' || maquina_nombre || ' fue terminada.',
                    'reparacion_finalizada',
                    NEW.id);
        END LOOP;

        IF NEW.tecnico_asignado_id IS NOT NULL THEN
            INSERT INTO notificaciones(usuario_id, titulo, mensaje, tipo, relacion_id)
            VALUES (NEW.tecnico_asignado_id,
                    'Reparación aceptada',
                    'El cliente confirmó la reparación de ' || maquina_nombre,
                    'reparacion_finalizada',
                    NEW.id);
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notificaciones_solicitudes
AFTER INSERT OR UPDATE ON solicitudes_reparacion
FOR EACH ROW EXECUTE FUNCTION crear_notificacion_automatica();

-- FUNCIONES

CREATE OR REPLACE FUNCTION obtener_maquinas_cliente(p_cliente_id bigint)
RETURNS TABLE(
    maquina_id bigint,
    nombre_maquina text,
    tipo_maquina text,
    estado_maquina estado_maquina,
    fecha_asignacion timestamptz
) AS $$
BEGIN
    RETURN QUERY
    SELECT m.id, m.nombre, m.tipo, m.estado, mc.fecha_asignacion
    FROM maquinas m
    INNER JOIN maquinas_cliente mc ON m.id = mc.maquina_id
    WHERE mc.cliente_id = p_cliente_id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION obtener_solicitudes_usuario(p_usuario_id bigint, p_rol tipo_rol)
RETURNS TABLE(
    solicitud_id bigint,
    maquina_nombre text,
    descripcion_falla text,
    gravedad gravedad_falla,
    estado_sol estado_solicitud,
    tecnico_nombre text,
    fecha_hora_reparacion timestamptz,
    fecha_creacion timestamptz
) AS $$
BEGIN
    IF p_rol = 'Cliente' THEN
        RETURN QUERY
        SELECT sr.id, m.nombre, sr.descripcion_falla, sr.gravedad, sr.estado,
               u.nombre_usuario, sr.fecha_hora_reparacion, sr.fecha_creacion
        FROM solicitudes_reparacion sr
        INNER JOIN maquinas m ON sr.maquina_id = m.id
        LEFT JOIN usuarios u ON sr.tecnico_asignado_id = u.id
        WHERE sr.cliente_id = p_usuario_id
        ORDER BY sr.fecha_creacion DESC;

    ELSIF p_rol = 'Tecnico' THEN
        RETURN QUERY
        SELECT sr.id, m.nombre, sr.descripcion_falla, sr.gravedad, sr.estado,
               u.nombre_usuario, sr.fecha_hora_reparacion, sr.fecha_creacion
        FROM solicitudes_reparacion sr
        INNER JOIN maquinas m ON sr.maquina_id = m.id
        LEFT JOIN usuarios u ON sr.tecnico_asignado_id = u.id
        WHERE sr.tecnico_asignado_id = p_usuario_id
        ORDER BY sr.fecha_creacion DESC;

    ELSE
        RETURN QUERY
        SELECT sr.id, m.nombre, sr.descripcion_falla, sr.gravedad, sr.estado,
               u.nombre_usuario, sr.fecha_hora_reparacion, sr.fecha_creacion
        FROM solicitudes_reparacion sr
        INNER JOIN maquinas m ON sr.maquina_id = m.id
        LEFT JOIN usuarios u ON sr.tecnico_asignado_id = u.id
        ORDER BY sr.fecha_creacion DESC;
    END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION obtener_tecnicos_activos()
RETURNS TABLE(
    tecnico_id bigint,
    nombre_tecnico text,
    correo_tecnico text
) AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.nombre_usuario, u.correo
    FROM usuarios u
    WHERE u.rol = 'Tecnico'
      AND u.activo = true
    ORDER BY u.nombre_usuario;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION asignar_tecnico_solicitud(
    p_solicitud_id bigint,
    p_tecnico_id bigint,
    p_fecha_hora_reparacion timestamptz
)
RETURNS void AS $$
BEGIN
    UPDATE solicitudes_reparacion
    SET tecnico_asignado_id = p_tecnico_id,
        fecha_hora_reparacion = p_fecha_hora_reparacion,
        estado = 'tecnico_asignado',
        fecha_actualizacion = NOW()
    WHERE id = p_solicitud_id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION marcar_reparacion_terminada(
    p_solicitud_id bigint,
    p_observaciones_tecnico text
)
RETURNS void AS $$
BEGIN
    UPDATE solicitudes_reparacion
    SET estado = 'prefinalizada',
        observaciones_tecnico = p_observaciones_tecnico,
        fecha_reparacion_terminada = NOW(),
        fecha_actualizacion = NOW()
    WHERE id = p_solicitud_id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION finalizar_solicitud_cliente(p_solicitud_id bigint)
RETURNS void AS $$
BEGIN
    UPDATE solicitudes_reparacion
    SET estado = 'finalizada',
        fecha_finalizada = NOW(),
        fecha_actualizacion = NOW()
    WHERE id = p_solicitud_id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION agregar_repuesto_utilizado(
    p_solicitud_id bigint,
    p_repuesto_id bigint,
    p_cantidad_utilizada integer
)
RETURNS void AS $$
BEGIN
    INSERT INTO repuestos_utilizados (solicitud_id, repuesto_id, cantidad_utilizada)
    VALUES (p_solicitud_id, p_repuesto_id, p_cantidad_utilizada);
END;
$$ LANGUAGE plpgsql;


-- VISTAS

CREATE OR REPLACE VIEW historial_reparaciones AS
SELECT 
    sr.id as solicitud_id,
    m.nombre as maquina_nombre,
    m.tipo as maquina_tipo,
    c.nombre_usuario as cliente_nombre,
    c.correo as cliente_correo,
    t.nombre_usuario as tecnico_nombre,
    t.correo as tecnico_correo,
    sr.descripcion_falla,
    sr.gravedad,
    sr.estado,
    sr.fecha_hora_reparacion,
    sr.fecha_creacion,
    sr.fecha_reparacion_terminada,
    sr.fecha_finalizada,
    sr.observaciones_tecnico,
    COUNT(ru.id) as cantidad_repuestos_utilizados,
    SUM(ru.cantidad_utilizada) as total_repuestos_utilizados
FROM solicitudes_reparacion sr
INNER JOIN maquinas m ON sr.maquina_id = m.id
INNER JOIN usuarios c ON sr.cliente_id = c.id
LEFT JOIN usuarios t ON sr.tecnico_asignado_id = t.id
LEFT JOIN repuestos_utilizados ru ON sr.id = ru.solicitud_id
GROUP BY sr.id, m.nombre, m.tipo, c.nombre_usuario, c.correo,
         t.nombre_usuario, t.correo, sr.descripcion_falla, sr.gravedad,
         sr.estado, sr.fecha_hora_reparacion, sr.fecha_creacion,
         sr.fecha_reparacion_terminada, sr.fecha_finalizada,
         sr.observaciones_tecnico;


CREATE OR REPLACE VIEW detalle_repuestos_utilizados AS
SELECT 
    ru.solicitud_id,
    sr.descripcion_falla,
    m.nombre as maquina_nombre,
    r.nombre as repuesto_nombre,
    ru.cantidad_utilizada,
    ru.fecha_uso,
    r.proveedor_id,
    p.nombre as proveedor_nombre
FROM repuestos_utilizados ru
INNER JOIN solicitudes_reparacion sr ON ru.solicitud_id = sr.id
INNER JOIN maquinas m ON sr.maquina_id = m.id
INNER JOIN repuestos r ON ru.repuesto_id = r.id
LEFT JOIN proveedores p ON r.proveedor_id = p.id
ORDER BY ru.fecha_uso DESC;

-- DOCUMENTACION

COMMENT ON TABLE solicitudes_reparacion IS 'Tabla principal de solicitudes de reparación.';
COMMENT ON TABLE repuestos_utilizados IS 'Repuestos utilizados en cada reparación.';
COMMENT ON TABLE notificaciones IS 'Sistema interno de notificaciones.';

COMMENT ON FUNCTION obtener_maquinas_cliente IS 'Devuelve las máquinas asignadas a un cliente.';
COMMENT ON FUNCTION obtener_solicitudes_usuario IS 'Devuelve solicitudes según rol.';
COMMENT ON FUNCTION obtener_tecnicos_activos IS 'Lista los técnicos activos.';
COMMENT ON FUNCTION asignar_tecnico_solicitud IS 'Asigna un técnico a una solicitud.';
COMMENT ON FUNCTION marcar_reparacion_terminada IS 'Marca una solicitud como prefinalizada.';
COMMENT ON FUNCTION finalizar_solicitud_cliente IS 'Finaliza la solicitud por el cliente.';
COMMENT ON FUNCTION agregar_repuesto_utilizado IS 'Registra un repuesto utilizado.';

-- CONSTRAINTS DE NOMBRES UNICOS
ALTER TABLE maquinas 
ADD CONSTRAINT unique_maquina_nombre UNIQUE (nombre);

ALTER TABLE proveedores 
ADD CONSTRAINT unique_proveedor_nombre UNIQUE (nombre);

ALTER TABLE repuestos 
ADD CONSTRAINT unique_repuesto_nombre UNIQUE (nombre);
